2409161636
	Status: #course #idea
		Tags:  [[Practical TLS]] 
# TLS-SSL Handshake


# TLS/SSL Records Structure and Types

## Overview

TLS/SSL conversations are composed of records. These records form the basic unit of data transmission in the TLS/SSL protocol.

## Record Types

1. Handshake
2. Alert
3. Change Cipher Spec
4. Application Data

## Record Subtypes

Some record types are further divided into subtypes:

### Handshake Subtypes:
- Client Hello
- Server Hello

### Alert Subtypes:
- Handshake Failure

## Record Transmission Characteristics

Records have a flexible relationship with network packets:

1. One record per packet
2. Multiple records in one packet
3. One record sent across multiple packets

Important: Records are not confined to or limited by IP datagram length.

## Record Structure

Each record begins with a header followed by the payload:

### Record Header Components:
1. Record Type
2. SSL Version
3. Record Length

### Record Payload:
- Contains the actual data for the specific record type

## Key Points

1. TLS/SSL uses a record-based structure for all communications.
2. Records are the fundamental units of data in TLS/SSL protocols.
3. The relationship between records and network packets is flexible.
4. Each record has a defined structure with a header and payload.
5. Understanding record types and structure is crucial for analyzing TLS/SSL traffic.



![[Pasted image 20240916163703.png]]
---






# TLS/SSL Records: Detailed Type Information

## Change Cipher Spec (Type 20)

- Indicates sender has everything needed to speak securely (cipher suites and session keys)
- Sent independently by both client and server
- Everything sent after this is encrypted
- Record payload is binary 0000 0001
- Length: 1 byte
- Signals readiness to speak securely

## Alert (Type 21)

- Informational notification
- Contains two items:
  1. Severity:
     - 01: Warning (session can continue)
     - 02: Fatal (session terminates)
  2. Description: Notification details
- Sent unencrypted unless after Change Cipher Spec

### Alert Description Codes

| Description | HEX | DEC |
|-------------|-----|-----|
| Handshake failure | 0x28 | 40 |
| Certificate revoked | 0x2A | 42 |
| Certificate expired | 0x2B | 43 |
| Unsupported extension | 0x6E | 110 |
| Unrecognized name | 0x70 | 112 |

## Handshake (Type 22)

- TLS/SSL negotiation messages
- Classified into sub-types
- Sent unencrypted, except for certain fields within specific subtypes

## Application Data (Type 23)

- Bulk data protected by SSL/TLS
  - Confidentiality
  - Integrity
  - Authentication
- TLS process:
  1. Calculates MAC on record header and plaintext data
  2. Encrypts:
     - Plaintext data
     - MAC digest
     - Padding

### TLS Encryption Approach

- TLS uses MAC-then-encrypt
  - Potential issue: Receiver doesn't know about tampering until decryption
  - Padding not included in MAC (no integrity on padding)

### AEAD (Authenticated Encryption with Associated Data)

- Solution to MAC-then-encrypt vulnerabilities
- Performs hashing and encryption in the same step
- AE (Authenticated Encryption): Integrity + Encryption
- AD (Associated Data): Integrity only
- Recommended approach
- TLS 1.3: All ciphers are AEAD
- TLS 1.2: AES-GCM, ChaCha20-Poly1305 support AEAD

```ad-note
title: Evolution of TLS Security
collapse: closed
icon: shield-alt

The move towards AEAD ciphers in TLS 1.2 and mandating them in TLS 1.3 represents a significant improvement in the protocol's security, addressing vulnerabilities associated with the traditional MAC-then-encrypt approach.
```







# TLS Handshake Process (RSA Example)

## Overview

The TLS handshake creates a protected tunnel between client and server, ensuring confidentiality, integrity, and authentication (CIA triad) for bulk data transfer.

## Handshake Steps

### 1. Client Hello

Client sends:
- Version: Highest TLS/SSL version supported
- Random number: 32 bytes (256 bits), first 4 bytes encode timestamp
- Session ID: 32 bits, all 0's in initial hello
- Cipher suites: List of supported cipher suites
- Extensions: Optional additional features

### 2. Server Hello

Server responds with:
- Version: Selected TLS/SSL version
- Random number: 32 bytes (256 bits), first 4 bytes encode timestamp
- Session ID: Generated by server to identify ensuing session
- Cipher suite: Selected from client's list
- Extensions: Agreed upon additional features

### 3. Certificate

Server sends:
- Server certificate
- Full certificate chain

### 4. Server Hello Done

Indicates server has nothing more to send at this time.

### 5. Certificate Validation (Client-side)

Client verifies:
1. Certificate legitimacy: Decrypt signature with CA's public key
2. Server ownership: Encrypt important information with server's public key

### 6. Client Key Exchange

Client sends:
- Pre-master secret: Encrypted with server's public key
  - 2 bytes: TLS/SSL version
  - 46 bytes: Random data

### 7. Key Calculation (Both sides)

Both parties calculate:
- Master secret: Using pre-master secret, client random, and server random
- Session keys: Using master secret, key expansion, client random, and server random

Four session keys created:
1. Client encryption key
2. Client HMAC key
3. Server encryption key
4. Server HMAC key

```ad-note
title: Pseudo-Random Function (PRF)
collapse: closed
icon: random

A hashing algorithm that generates digests of any desired length, used in key calculations.
```

### 8. Client Change Cipher Spec

Client indicates readiness to use negotiated cipher suite and keys.

### 9. Client Finished

Client sends:
- Hash of all previous handshake messages, encrypted with session keys

### 10. Server Change Cipher Spec

Server indicates readiness to use negotiated cipher suite and keys.

### 11. Server Finished

Server sends:
- Hash of all handshake messages, encrypted with session keys

## Key Points

- Both parties independently calculate identical session keys
- Two sets of keys (client and server) create bidirectional secure tunnels
- Finished messages prove both parties have correct session keys
- Change Cipher Spec messages indicate switch to secured communication

```ad-info
title: Security Through Separation
collapse: closed
icon: lock

Using separate keys for client and server communication enhances security. If one set of keys is compromised, the other direction remains secure.
```

![[Pasted image 20240919201829.png]]




# TLS Handshake: Ephemeral Diffie-Hellman (DHE) Key Exchange

## Overview

Ephemeral Diffie-Hellman (DHE) is an alternative key exchange method in TLS, offering different security properties compared to RSA key exchange.

## Key Differences from RSA

1. Mutual Contribution: Both client and server contribute to the seed value
2. Forward Secrecy: Session keys cannot be recovered if the server's long-term private key is compromised

## DHE Handshake Process

### 1. Client Hello
- Same as in RSA handshake

### 2. Server Hello
- Same as in RSA handshake

### 3. Server Key Exchange (New step)
Server sends:
- DH parameters (prime, generator)
- Server's DH public value
- Signature of above data, signed with server's private key

### 4. Server Hello Done
- Indicates server has sent all necessary information

### 5. Client Key Exchange
Client sends:
- Client's DH public value (not encrypted)

### 6. Key Calculation
Both parties:
- Calculate DH shared secret using their own private value and the other's public value
- Use DH shared secret to derive the pre-master secret
- Calculate master secret and session keys (similar to RSA process)

## Proving Server Identity

1. Server signs its DH public value with its private key
2. Client verifies signature using server's public key from the certificate
3. Successful verification proves server possesses the matching private key

## Security Benefits

```ad-info
title: Forward Secrecy
collapse: closed
icon: shield-alt

DHE provides forward secrecy: If the server's long-term private key is compromised in the future, past session keys cannot be recovered. This is because the ephemeral DH values are discarded after the handshake.
```

## Comparison with RSA Key Exchange

| Aspect | RSA | DHE |
|--------|-----|-----|
| Seed Value Contribution | Client only | Both client and server |
| Server Identity Proof | Decryption of pre-master secret | Signature verification |
| Forward Secrecy | No | Yes |
| Computational Cost | Lower | Higher |
| Key Reuse | Same key for encryption and signing | Separate keys possible |

## Key Points

1. DHE involves more steps in the handshake compared to RSA
2. Both parties actively contribute to the final shared secret
3. The server must sign its DH parameters and public value
4. Provides forward secrecy, enhancing long-term security
5. Slightly higher computational cost compared to RSA

```ad-note
title: Ephemeral Nature
collapse: closed
icon: clock

The "Ephemeral" in DHE means that new DH parameters are generated for each session, enhancing security but increasing computational load.
```





![[Pasted image 20240930153129.png]]








# TLS Session Resumption

## Problem Addressed

Full TLS handshakes are resource-intensive:
- Require 9+ records
- Two full round trips before data transmission
- Require sending certificate and full certificate chain
- Involve asymmetric cryptography calculations

## Benefits of Correct Implementation

1. Reduced latency: Fewer round trips required
2. Lower computational overhead: Avoids full cryptographic negotiations
3. Improved user experience: Faster connection establishment

```ad-warning
title: Security Considerations
collapse: closed
icon: shield-alt

While session resumption improves performance, it's important to balance this with security needs. Servers should implement appropriate policies for session lifetime and rotation.
```

## Session Resumption Solution

Quickly resume a previous session with an abbreviated handshake:
- Requires only 6 records
- One round trip
- No need to resend certificates
- No asymmetric cryptography calculations

```ad-note
title: Security Consideration
collapse: closed
icon: shield-alt

Session resumption is not the same as session renegotiation, which has known security vulnerabilities.
```

## Session Resumption Process

1. Client Hello:
   - Client sends the previously received Session ID

2. Server Hello:
   - If agreeing to resume: Server sends back the same Session ID
   - If declining resumption: Server generates and sends a new random Session ID

```ad-info
title: Server Decision
collapse: closed
icon: server

The server has the final say in whether to resume a session. It may decline for various reasons, including security policies or if it has discarded the session information.
```


![[Pasted image 20240930154615.png]]



### Abbreviated Handshake
1. Client Hello:
   - Includes previously received Session ID

2. Server Hello:
   - If agreeing to resume: Returns the same Session ID
   - If declining: Returns a new, randomly generated Session ID

3. Server sends:
   - Change Cipher Spec record
   - Finished record

4. Client sends:
   - Change Cipher Spec record
   - Finished record

![[Pasted image 20240930154715.png]]

## Key Points
- Both parties must agree to resume the previous session
- Communication of intent is through Session IDs
- Server can choose to accept or deny the resumption request
- Only 6 records and one round trip required

## Session Key Generation

### Original Session Keys
Created from four values: Master secret,Key expansion, client random, server random
![[Pasted image 20240930160127.png]]



### Resumed Session Keys
Created similarly to original, using:
- Previous session's master secret
- New session's client random
- New session's server random

```ad-info
title: Key Variation
collapse: closed
icon: key

Resumed session keys are not identical to the previous session's keys, but are derived using the previous session's master secret.
```



## Verification Process
1. Each party calculates hash of all handshake records
2. Hash is encrypted with sender's session keys
3. Receiving party verifies with identical keys




![[Pasted image 20240930155211.png]]





## Benefits of Session Resumption
1. Reduced latency (one round trip vs. two)
2. Lower computational overhead (no asymmetric cryptography)
3. Reduced network traffic (fewer records transmitted)
4. Faster connection establishment

## Use Cases
- High-volume web servers
- Mobile applications with frequent reconnections
- IoT devices with intermittent connectivity

```ad-warning
title: Security Trade-offs
collapse: closed
icon: balance-scale

While session resumption improves performance, it may slightly reduce security by reusing some cryptographic material. The trade-off is generally considered acceptable for most use cases.
```













# Reference