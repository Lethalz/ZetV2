2409161636
	Status: #course #idea
		Tags:  [[Practical TLS]] 
# TLS-SSL Handshake


# TLS/SSL Records Structure and Types

## Overview

TLS/SSL conversations are composed of records. These records form the basic unit of data transmission in the TLS/SSL protocol.

## Record Types

1. Handshake
2. Alert
3. Change Cipher Spec
4. Application Data

## Record Subtypes

Some record types are further divided into subtypes:

### Handshake Subtypes:
- Client Hello
- Server Hello

### Alert Subtypes:
- Handshake Failure

## Record Transmission Characteristics

Records have a flexible relationship with network packets:

1. One record per packet
2. Multiple records in one packet
3. One record sent across multiple packets

Important: Records are not confined to or limited by IP datagram length.

## Record Structure

Each record begins with a header followed by the payload:

### Record Header Components:
1. Record Type
2. SSL Version
3. Record Length

### Record Payload:
- Contains the actual data for the specific record type

## Key Points

1. TLS/SSL uses a record-based structure for all communications.
2. Records are the fundamental units of data in TLS/SSL protocols.
3. The relationship between records and network packets is flexible.
4. Each record has a defined structure with a header and payload.
5. Understanding record types and structure is crucial for analyzing TLS/SSL traffic.



![[Pasted image 20240916163703.png]]
---

--- 




# TLS/SSL Records: Detailed Type Information

## Change Cipher Spec (Type 20)

- Indicates sender has everything needed to speak securely (cipher suites and session keys)
- Sent independently by both client and server
- Everything sent after this is encrypted
- Record payload is binary 0000 0001
- Length: 1 byte
- Signals readiness to speak securely

## Alert (Type 21)

- Informational notification
- Contains two items:
  1. Severity:
     - 01: Warning (session can continue)
     - 02: Fatal (session terminates)
  2. Description: Notification details
- Sent unencrypted unless after Change Cipher Spec

### Alert Description Codes

| Description | HEX | DEC |
|-------------|-----|-----|
| Handshake failure | 0x28 | 40 |
| Certificate revoked | 0x2A | 42 |
| Certificate expired | 0x2B | 43 |
| Unsupported extension | 0x6E | 110 |
| Unrecognized name | 0x70 | 112 |

## Handshake (Type 22)

- TLS/SSL negotiation messages
- Classified into sub-types
- Sent unencrypted, except for certain fields within specific subtypes

## Application Data (Type 23)

- Bulk data protected by SSL/TLS
  - Confidentiality
  - Integrity
  - Authentication
- TLS process:
  1. Calculates MAC on record header and plaintext data
  2. Encrypts:
     - Plaintext data
     - MAC digest
     - Padding

### TLS Encryption Approach

- TLS uses MAC-then-encrypt
  - Potential issue: Receiver doesn't know about tampering until decryption
  - Padding not included in MAC (no integrity on padding)

### AEAD (Authenticated Encryption with Associated Data)

- Solution to MAC-then-encrypt vulnerabilities
- Performs hashing and encryption in the same step
- AE (Authenticated Encryption): Integrity + Encryption
- AD (Associated Data): Integrity only
- Recommended approach
- TLS 1.3: All ciphers are AEAD
- TLS 1.2: AES-GCM, ChaCha20-Poly1305 support AEAD

```ad-note
title: Evolution of TLS Security
collapse: closed
icon: shield-alt

The move towards AEAD ciphers in TLS 1.2 and mandating them in TLS 1.3 represents a significant improvement in the protocol's security, addressing vulnerabilities associated with the traditional MAC-then-encrypt approach.
```



--- 



# TLS Handshake Process (RSA Example)

## Overview

The TLS handshake creates a protected tunnel between client and server, ensuring confidentiality, integrity, and authentication (CIA triad) for bulk data transfer.

## Handshake Steps

### 1. Client Hello

Client sends:
- Version: Highest TLS/SSL version supported
- Random number: 32 bytes (256 bits), first 4 bytes encode timestamp
- Session ID: 32 bits, all 0's in initial hello
- Cipher suites: List of supported cipher suites
- Extensions: Optional additional features

### 2. Server Hello

Server responds with:
- Version: Selected TLS/SSL version
- Random number: 32 bytes (256 bits), first 4 bytes encode timestamp
- Session ID: Generated by server to identify ensuing session
- Cipher suite: Selected from client's list
- Extensions: Agreed upon additional features

### 3. Certificate

Server sends:
- Server certificate
- Full certificate chain

### 4. Server Hello Done

Indicates server has nothing more to send at this time.

### 5. Certificate Validation (Client-side)

Client verifies:
1. Certificate legitimacy: Decrypt signature with CA's public key
2. Server ownership: Encrypt important information with server's public key

### 6. Client Key Exchange

Client sends:
- Pre-master secret: Encrypted with server's public key
  - 2 bytes: TLS/SSL version
  - 46 bytes: Random data

### 7. Key Calculation (Both sides)

Both parties calculate:
- Master secret: Using pre-master secret, client random, and server random
- Session keys: Using master secret, key expansion, client random, and server random

Four session keys created:
1. Client encryption key
2. Client HMAC key
3. Server encryption key
4. Server HMAC key

```ad-note
title: Pseudo-Random Function (PRF)
collapse: closed
icon: random

A hashing algorithm that generates digests of any desired length, used in key calculations.
```

### 8. Client Change Cipher Spec

Client indicates readiness to use negotiated cipher suite and keys.

### 9. Client Finished

Client sends:
- Hash of all previous handshake messages, encrypted with session keys

### 10. Server Change Cipher Spec

Server indicates readiness to use negotiated cipher suite and keys.

### 11. Server Finished

Server sends:
- Hash of all handshake messages, encrypted with session keys

## Key Points

- Both parties independently calculate identical session keys
- Two sets of keys (client and server) create bidirectional secure tunnels
- Finished messages prove both parties have correct session keys
- Change Cipher Spec messages indicate switch to secured communication

```ad-info
title: Security Through Separation
collapse: closed
icon: lock

Using separate keys for client and server communication enhances security. If one set of keys is compromised, the other direction remains secure.
```

![[Pasted image 20240919201829.png]]


--- 

# TLS Handshake: Ephemeral Diffie-Hellman (DHE) Key Exchange

## Overview

Ephemeral Diffie-Hellman (DHE) is an alternative key exchange method in TLS, offering different security properties compared to RSA key exchange.

## Key Differences from RSA

1. Mutual Contribution: Both client and server contribute to the seed value
2. Forward Secrecy: Session keys cannot be recovered if the server's long-term private key is compromised

## DHE Handshake Process

### 1. Client Hello
- Same as in RSA handshake

### 2. Server Hello
- Same as in RSA handshake

### 3. Server Key Exchange (New step)
Server sends:
- DH parameters (prime, generator)
- Server's DH public value
- Signature of above data, signed with server's private key

### 4. Server Hello Done
- Indicates server has sent all necessary information

### 5. Client Key Exchange
Client sends:
- Client's DH public value (not encrypted)

### 6. Key Calculation
Both parties:
- Calculate DH shared secret using their own private value and the other's public value
- Use DH shared secret to derive the pre-master secret
- Calculate master secret and session keys (similar to RSA process)

## Proving Server Identity

1. Server signs its DH public value with its private key
2. Client verifies signature using server's public key from the certificate
3. Successful verification proves server possesses the matching private key

## Security Benefits

```ad-info
title: Forward Secrecy
collapse: closed
icon: shield-alt

DHE provides forward secrecy: If the server's long-term private key is compromised in the future, past session keys cannot be recovered. This is because the ephemeral DH values are discarded after the handshake.
```

## Comparison with RSA Key Exchange

| Aspect | RSA | DHE |
|--------|-----|-----|
| Seed Value Contribution | Client only | Both client and server |
| Server Identity Proof | Decryption of pre-master secret | Signature verification |
| Forward Secrecy | No | Yes |
| Computational Cost | Lower | Higher |
| Key Reuse | Same key for encryption and signing | Separate keys possible |

## Key Points

1. DHE involves more steps in the handshake compared to RSA
2. Both parties actively contribute to the final shared secret
3. The server must sign its DH parameters and public value
4. Provides forward secrecy, enhancing long-term security
5. Slightly higher computational cost compared to RSA

```ad-note
title: Ephemeral Nature
collapse: closed
icon: clock

The "Ephemeral" in DHE means that new DH parameters are generated for each session, enhancing security but increasing computational load.
```





![[Pasted image 20240930153129.png]]





--- 


# TLS Session Resumption

## Problem Addressed

Full TLS handshakes are resource-intensive:
- Require 9+ records
- Two full round trips before data transmission
- Require sending certificate and full certificate chain
- Involve asymmetric cryptography calculations

## Benefits of Correct Implementation

1. Reduced latency: Fewer round trips required
2. Lower computational overhead: Avoids full cryptographic negotiations
3. Improved user experience: Faster connection establishment

```ad-warning
title: Security Considerations
collapse: closed
icon: shield-alt

While session resumption improves performance, it's important to balance this with security needs. Servers should implement appropriate policies for session lifetime and rotation.
```

## Session Resumption Solution

Quickly resume a previous session with an abbreviated handshake:
- Requires only 6 records
- One round trip
- No need to resend certificates
- No asymmetric cryptography calculations

```ad-note
title: Security Consideration
collapse: closed
icon: shield-alt

Session resumption is not the same as session renegotiation, which has known security vulnerabilities.
```

## Session Resumption Process

1. Client Hello:
   - Client sends the previously received Session ID

2. Server Hello:
   - If agreeing to resume: Server sends back the same Session ID
   - If declining resumption: Server generates and sends a new random Session ID

```ad-info
title: Server Decision
collapse: closed
icon: server

The server has the final say in whether to resume a session. It may decline for various reasons, including security policies or if it has discarded the session information.
```


![[Pasted image 20240930154615.png]]



### Abbreviated Handshake
1. Client Hello:
   - Includes previously received Session ID

2. Server Hello:
   - If agreeing to resume: Returns the same Session ID
   - If declining: Returns a new, randomly generated Session ID

3. Server sends:
   - Change Cipher Spec record
   - Finished record

4. Client sends:
   - Change Cipher Spec record
   - Finished record

![[Pasted image 20240930154715.png]]

## Key Points
- Both parties must agree to resume the previous session
- Communication of intent is through Session IDs
- Server can choose to accept or deny the resumption request
- Only 6 records and one round trip required

## Session Key Generation

### Original Session Keys
Created from four values: Master secret,Key expansion, client random, server random
![[Pasted image 20240930160127.png]]



### Resumed Session Keys
Created similarly to original, using:
- Previous session's master secret
- New session's client random
- New session's server random

```ad-info
title: Key Variation
collapse: closed
icon: key

Resumed session keys are not identical to the previous session's keys, but are derived using the previous session's master secret.
```



## Verification Process
1. Each party calculates hash of all handshake records
2. Hash is encrypted with sender's session keys
3. Receiving party verifies with identical keys




![[Pasted image 20240930155211.png]]





## Benefits of Session Resumption
1. Reduced latency (one round trip vs. two)
2. Lower computational overhead (no asymmetric cryptography)
3. Reduced network traffic (fewer records transmitted)
4. Faster connection establishment

## Use Cases
- High-volume web servers
- Mobile applications with frequent reconnections
- IoT devices with intermittent connectivity

```ad-warning
title: Security Trade-offs
collapse: closed
icon: balance-scale

While session resumption improves performance, it may slightly reduce security by reusing some cryptographic material. The trade-off is generally considered acceptable for most use cases.
```










# TLS/SSL: Mutual Authentication and Extensions

## Mutual Authentication

In typical TLS/SSL, only the server is authenticated. Mutual authentication allows both client and server to authenticate each other.

![[Pasted image 20241001092044.png]]
### Process:

1. Handshake: Certificate Request (Server)
   - Server requests client's certificate
   - Optionally includes:
     - Type of certificate
     - List of trusted Certificate Authorities (CAs)

2. Handshake: Certificate (Client)
   - Client sends its certificate and certificate chain

3. Certificate Validation
   - Server validates client's certificate:
     a. Is the client certificate valid? (Checked using CA's public key)
     b. Is the client the true owner of the certificate? (Verified by client's possession of the correct private key)
   - Client validates server's certificate (as in standard TLS)

4. Handshake: Certificate Verify (Client)
   - Proves client is the true owner of the certificate
   - Client calculates hash of all handshake records
   - Client creates signature of hash with its private key

```ad-note
title: Use Cases
collapse: closed
icon: info-circle

Mutual authentication is rare for HTTPS websites but more common in SSL VPNs and certain enterprise applications.
```


![[Pasted image 20241001092635.png]]


## TLS Extensions

Extensions add features to TLS/SSL without rewriting the RFC.


![[Pasted image 20241001094917.png]]




### Characteristics:
- Typically client-initiated
- Client suggests extensions and includes necessary info
- Server responds with supported extensions

### Server Response Options:
1. Respond normally, ignoring unsupported extensions
2. Terminate the session (rare)
3. Respond with an alert: handshake failure

```ad-warning
title: Client Response
collapse: closed
icon: exclamation-triangle

If a server responds with an extension not initiated by the client, the client must terminate the handshake with an "unsupported extension" alert.
```

### Main Extensions:
1. OCSP Stapling
2. Server Name Indication (SNI)
3. Session Tickets

## OCSP Stapling Extension

OCSP (Online Certificate Status Protocol) Stapling allows the server to provide certificate status information directly.


![[Pasted image 20241001132626.png]]



### Process:
1. Server periodically asks CA for its own status
2. Client requests certificate and status in Client Hello
3. Server confirms support in Server Hello
4. Server sends status in Certificate Status handshake record

![[Pasted image 20241001140034.png]]
### If Server Doesn't Support OCSP Stapling:
- Server doesn't echo status request extension
- Client proceeds to check revocation status via CRL or OCSP

```ad-info
title: Efficiency
collapse: closed
icon: tachometer-alt

OCSP Stapling reduces the need for clients to make separate OCSP requests, improving performance and reducing load on OCSP responders.
```


# TLS Extension: Server Name Indication (SNI)

## Background

### Traditional Web Hosting
- Each server typically hosted only one website
- Legacy approach, not scalable for modern web

### Modern Web Hosting
- Servers host multiple websites
- Requires sending Host header in HTTP request

## The Challenge with TLS/SSL

- TLS/SSL tunnel protects the HTTP conversation
- TLS doesn't inherently know which site the client is trying to access
- Traditional TLS/SSL:
  - Server sends certificate based on destination IP
  - Each server can only host one HTTPS website
  - Multiple HTTPS sites require multiple IP addresses

## Server Name Indication (SNI) Solution

SNI allows a server to host multiple HTTPS websites on a single IP address.

### Process

1. Client Hello:
   - Client sends SNI extension
   - Includes the hostname of the requested website

2. Server Hello:
   - Server confirms support for SNI

3. Certificate:
   - Server sends appropriate certificate for the requested hostname

```ad-info
title: Efficiency Gain
collapse: closed
icon: server

SNI enables efficient use of IP addresses, allowing multiple secure websites to be hosted on a single server with a single IP.
```

### Scenarios

#### Server Supports SNI:
- Server confirms support in Server Hello
- Sends certificate matching the requested hostname

#### Server Doesn't Support SNI:
- Server doesn't send SNI extension in Server Hello
- Sends fallback certificate bound to server's IP address
- Client still verifies if certificate CN/SAN matches requested hostname

#### Unrecognized Hostname:
- Server may send alert: "unrecognized name"
- Alternatively, server may continue with fallback certificate
- Client verifies if certificate CN/SAN matches requested website

```ad-warning
title: Compatibility
collapse: closed
icon: exclamation-triangle

Older clients may not support SNI. Servers should have a fallback strategy to handle these cases, typically using a default certificate.
```

## Benefits of SNI

1. Resource Efficiency: Allows hosting multiple HTTPS sites on one IP address
2. Cost-Effective: Reduces need for multiple IP addresses
3. Scalability: Facilitates easier management of multiple secure websites
4. Improved User Experience: Enables correct certificate delivery without user intervention

## Considerations

- Client Support: Ensure your target audience uses SNI-compatible clients
- Server Configuration: Proper setup is crucial for correct certificate delivery
- Fallback Strategies: Important for handling non-SNI clients or unrecognized hostnames

```ad-tip
title: Best Practice
collapse: closed
icon: lightbulb

When implementing SNI, always have a well-configured fallback certificate to ensure all clients can establish a secure connection, even if not optimally matched to the requested hostname.
```






---




# TLS Extension: Session Tickets

## Purpose

Session Tickets enable session resumption across multiple servers hosting the same website, allowing an entire server fleet to perform session resumption efficiently.

## Process

1. Initial Handshake:
   - Client performs full TLS handshake with a server
   - Server creates a session ticket
   - Ticket includes master secret and other session details
   - Ticket is encrypted with Session Ticket Encryption Key (STEK)
     - STEK is shared across all servers in the fleet

2. Subsequent Connections:
   - Client includes session ticket in new connection
   - New server can extract master secret using STEK
   - Any server in the fleet can resume the client's session
![[Pasted image 20241002150543.png]]
## Handshake Details

1. Client Hello:
   - Client indicates support for session tickets (empty extension)

2. Server Hello:
   - Server confirms support for session tickets (empty extension)

3. Post-Handshake:
   - After client sends Change Cipher Spec and Finished records
   - Server sends session ticket in New Session Ticket record

4. Reconnection:
   - Client includes session ticket in next Client Hello
   - Server confirms support in Server Hello
   - Server continues with abbreviated session resumption handshake

```ad-info
title: Optional Refresh
collapse: closed
icon: sync

The server has the option to refresh the session ticket after receiving the old one, but this is optional.
```

### After Client has Session Ticket for server (reconnection)

Abbreviated Handshake after session ticket is confirmed

![[Pasted image 20241002151340.png]]
## Benefits

1. Scalability: Enables session resumption across multiple servers
2. Performance: Reduces handshake overhead for returning clients
3. Load Distribution: Allows any server in the fleet to handle resumed sessions

## Criticisms

1. Key Management:
   - Coordinated STEK rotation for the entire server fleet is challenging

2. Security Concerns:
   - Session ticket is sent before Change Cipher Spec
   - This means the ticket is sent before the secure encryption is established

3. Forward Secrecy Issues:
   - STEK compromises can defeat forward secrecy
   - If STEK is compromised, master secrets for all sessions can be extracted
   - Compromising STEK potentially exposes every session

```ad-warning
title: TLS 1.3 Changes
collapse: closed
icon: exclamation-triangle

TLS 1.3 changes the way Session Tickets work to address some of these security concerns. Always consider using the latest TLS version when possible.
```

## Implementation Considerations

1. STEK Management:
   - Implement secure and coordinated key rotation across the server fleet
   - Consider the trade-off between key rotation frequency and operational complexity

2. Monitoring:
   - Implement monitoring for unusual patterns in session ticket usage
   - Be prepared to revoke and rotate STEKs if compromise is suspected

3. Client Compatibility:
   - Ensure fallback mechanisms for clients that don't support session tickets

4. Forward Secrecy:
   - Consider the impact on forward secrecy when implementing session tickets
   - Evaluate if the performance benefits outweigh the potential security trade-offs

```ad-tip
title: Best Practice
collapse: closed
icon: shield-alt

When implementing session tickets, establish a strict STEK rotation policy and consider using shorter session durations to mitigate the impact of potential STEK compromises.
```















