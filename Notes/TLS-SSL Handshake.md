2409161636
	Status: #course #idea
		Tags:  [[Practical TLS]] 
# TLS-SSL Handshake


# TLS/SSL Records Structure and Types

## Overview

TLS/SSL conversations are composed of records. These records form the basic unit of data transmission in the TLS/SSL protocol.

## Record Types

1. Handshake
2. Alert
3. Change Cipher Spec
4. Application Data

## Record Subtypes

Some record types are further divided into subtypes:

### Handshake Subtypes:
- Client Hello
- Server Hello

### Alert Subtypes:
- Handshake Failure

## Record Transmission Characteristics

Records have a flexible relationship with network packets:

1. One record per packet
2. Multiple records in one packet
3. One record sent across multiple packets

Important: Records are not confined to or limited by IP datagram length.

## Record Structure

Each record begins with a header followed by the payload:

### Record Header Components:
1. Record Type
2. SSL Version
3. Record Length

### Record Payload:
- Contains the actual data for the specific record type

## Key Points

1. TLS/SSL uses a record-based structure for all communications.
2. Records are the fundamental units of data in TLS/SSL protocols.
3. The relationship between records and network packets is flexible.
4. Each record has a defined structure with a header and payload.
5. Understanding record types and structure is crucial for analyzing TLS/SSL traffic.



![[Pasted image 20240916163703.png]]
---






# TLS/SSL Records: Detailed Type Information

## Change Cipher Spec (Type 20)

- Indicates sender has everything needed to speak securely (cipher suites and session keys)
- Sent independently by both client and server
- Everything sent after this is encrypted
- Record payload is binary 0000 0001
- Length: 1 byte
- Signals readiness to speak securely

## Alert (Type 21)

- Informational notification
- Contains two items:
  1. Severity:
     - 01: Warning (session can continue)
     - 02: Fatal (session terminates)
  2. Description: Notification details
- Sent unencrypted unless after Change Cipher Spec

### Alert Description Codes

| Description | HEX | DEC |
|-------------|-----|-----|
| Handshake failure | 0x28 | 40 |
| Certificate revoked | 0x2A | 42 |
| Certificate expired | 0x2B | 43 |
| Unsupported extension | 0x6E | 110 |
| Unrecognized name | 0x70 | 112 |

## Handshake (Type 22)

- TLS/SSL negotiation messages
- Classified into sub-types
- Sent unencrypted, except for certain fields within specific subtypes

## Application Data (Type 23)

- Bulk data protected by SSL/TLS
  - Confidentiality
  - Integrity
  - Authentication
- TLS process:
  1. Calculates MAC on record header and plaintext data
  2. Encrypts:
     - Plaintext data
     - MAC digest
     - Padding

### TLS Encryption Approach

- TLS uses MAC-then-encrypt
  - Potential issue: Receiver doesn't know about tampering until decryption
  - Padding not included in MAC (no integrity on padding)

### AEAD (Authenticated Encryption with Associated Data)

- Solution to MAC-then-encrypt vulnerabilities
- Performs hashing and encryption in the same step
- AE (Authenticated Encryption): Integrity + Encryption
- AD (Associated Data): Integrity only
- Recommended approach
- TLS 1.3: All ciphers are AEAD
- TLS 1.2: AES-GCM, ChaCha20-Poly1305 support AEAD

```ad-note
title: Evolution of TLS Security
collapse: closed
icon: shield-alt

The move towards AEAD ciphers in TLS 1.2 and mandating them in TLS 1.3 represents a significant improvement in the protocol's security, addressing vulnerabilities associated with the traditional MAC-then-encrypt approach.
```







# TLS Handshake Process (RSA Example)

## Overview

The TLS handshake creates a protected tunnel between client and server, ensuring confidentiality, integrity, and authentication (CIA triad) for bulk data transfer.

## Handshake Steps

### 1. Client Hello

Client sends:
- Version: Highest TLS/SSL version supported
- Random number: 32 bytes (256 bits), first 4 bytes encode timestamp
- Session ID: 32 bits, all 0's in initial hello
- Cipher suites: List of supported cipher suites
- Extensions: Optional additional features

### 2. Server Hello

Server responds with:
- Version: Selected TLS/SSL version
- Random number: 32 bytes (256 bits), first 4 bytes encode timestamp
- Session ID: Generated by server to identify ensuing session
- Cipher suite: Selected from client's list
- Extensions: Agreed upon additional features

### 3. Certificate

Server sends:
- Server certificate
- Full certificate chain

### 4. Server Hello Done

Indicates server has nothing more to send at this time.

### 5. Certificate Validation (Client-side)

Client verifies:
1. Certificate legitimacy: Decrypt signature with CA's public key
2. Server ownership: Encrypt important information with server's public key

### 6. Client Key Exchange

Client sends:
- Pre-master secret: Encrypted with server's public key
  - 2 bytes: TLS/SSL version
  - 46 bytes: Random data

### 7. Key Calculation (Both sides)

Both parties calculate:
- Master secret: Using pre-master secret, client random, and server random
- Session keys: Using master secret, key expansion, client random, and server random

Four session keys created:
1. Client encryption key
2. Client HMAC key
3. Server encryption key
4. Server HMAC key

```ad-note
title: Pseudo-Random Function (PRF)
collapse: closed
icon: random

A hashing algorithm that generates digests of any desired length, used in key calculations.
```

### 8. Client Change Cipher Spec

Client indicates readiness to use negotiated cipher suite and keys.

### 9. Client Finished

Client sends:
- Hash of all previous handshake messages, encrypted with session keys

### 10. Server Change Cipher Spec

Server indicates readiness to use negotiated cipher suite and keys.

### 11. Server Finished

Server sends:
- Hash of all handshake messages, encrypted with session keys

## Key Points

- Both parties independently calculate identical session keys
- Two sets of keys (client and server) create bidirectional secure tunnels
- Finished messages prove both parties have correct session keys
- Change Cipher Spec messages indicate switch to secured communication

```ad-info
title: Security Through Separation
collapse: closed
icon: lock

Using separate keys for client and server communication enhances security. If one set of keys is compromised, the other direction remains secure.
```

![[Pasted image 20240919201829.png]]









# Reference